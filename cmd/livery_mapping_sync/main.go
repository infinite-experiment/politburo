package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// Note: UUID is auto-generated by PostgreSQL via DEFAULT gen_random_uuid()

// ===== CONFIGURATION =====
const (
	// VA ID to sync mappings for - UPDATE THIS FOR YOUR VA
	VA_ID = "b3acf56f-8ff8-4505-ab32-be63d25dc19b"

	// Path to mapping file (relative to where script is run)
	MAPPINGS_FILE = "../if_afklm_mappings.json"
)

// ===== MODELS =====

type LiveryAirtableMapping struct {
	ID          string `gorm:"column:id;primaryKey;type:uuid;default:gen_random_uuid()"`
	VAID        string `gorm:"uniqueIndex:,composite:va_livery_field_unique"`
	LiveryID    string `gorm:"uniqueIndex:,composite:va_livery_field_unique"`
	FieldType   string `gorm:"uniqueIndex:,composite:va_livery_field_unique"` // 'aircraft' or 'airline'
	SourceValue string
	TargetValue string
	IsActive    bool      `gorm:"default:true"`
	CreatedAt   time.Time `gorm:"autoCreateTime"`
	UpdatedAt   time.Time `gorm:"autoUpdateTime"`
}

type AircraftLivery struct {
	ID           string `gorm:"primaryKey"`
	LiveryID     string
	AircraftName string
	AircraftID   string
	LiveryName   string
	IsActive     bool
}

type MappingsFile struct {
	AircraftMappings map[string]string `json:"AircraftMappings"`
	AirlineMappings  map[string]string `json:"AirlineMappings"`
}

// ===== MAIN =====

func main() {
	log.Println("=== Livery Airtable Mappings Sync ===")
	log.Printf("Target VA ID: %s\n", VA_ID)

	// Validate VA_ID
	if VA_ID == "your-va-uuid-here" {
		log.Fatal("ERROR: Please update VA_ID constant at the top of the script")
	}

	// 1. Load mappings file
	log.Println("\n[1/4] Loading if_afklm_mappings.json...")
	mappings, err := loadMappingsFile(MAPPINGS_FILE)
	if err != nil {
		log.Fatalf("Failed to load mappings file: %v\n", err)
	}
	log.Printf("Loaded %d aircraft mappings and %d airline mappings\n",
		len(mappings.AircraftMappings), len(mappings.AirlineMappings))

	// 2. Connect to database
	log.Println("\n[2/4] Connecting to database...")
	db, err := connectDB()
	if err != nil {
		log.Fatalf("Failed to connect to database: %v\n", err)
	}
	log.Println("Connected successfully")

	// 3. Fetch liveries from aircraft_liveries table
	log.Println("\n[3/4] Fetching liveries from aircraft_liveries table...")
	liveries, err := fetchLiveries(db)
	if err != nil {
		log.Fatalf("Failed to fetch liveries: %v\n", err)
	}
	log.Printf("Found %d liveries to map\n", len(liveries))

	// 4. Create mappings and insert into database
	log.Println("\n[4/4] Creating and inserting mappings...")
	created, updated, err := syncMappings(db, liveries, mappings)
	if err != nil {
		log.Fatalf("Failed to sync mappings: %v\n", err)
	}

	// Summary
	log.Println("\n=== SYNC COMPLETE ===")
	log.Printf("Created: %d mapping rows\n", created)
	log.Printf("Updated: %d mapping rows\n", updated)
	log.Printf("Total mapping rows written: %d (2 per livery)\n", created+updated)
}

// ===== FUNCTIONS =====

func loadMappingsFile(path string) (*MappingsFile, error) {
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	var mappings MappingsFile
	if err := json.Unmarshal(data, &mappings); err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %w", err)
	}

	return &mappings, nil
}

func connectDB() (*gorm.DB, error) {
	dsn := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		os.Getenv("PG_HOST"),
		os.Getenv("PG_PORT"),
		os.Getenv("PG_USER"),
		os.Getenv("PG_PASSWORD"),
		os.Getenv("PG_DB"),
	)

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		return nil, fmt.Errorf("failed to connect: %w", err)
	}

	return db, nil
}

func fetchLiveries(db *gorm.DB) ([]AircraftLivery, error) {
	var liveries []AircraftLivery
	result := db.Table("aircraft_liveries").
		Where("is_active = true").
		Find(&liveries)

	if result.Error != nil {
		return nil, fmt.Errorf("failed to fetch liveries: %w", result.Error)
	}

	return liveries, nil
}

func syncMappings(db *gorm.DB, liveries []AircraftLivery, mappings *MappingsFile) (int, int, error) {
	created := 0
	updated := 0

	for _, livery := range liveries {
		// Match aircraft_name column with AircraftMappings
		aircraftTarget, aircraftExists := mappings.AircraftMappings[livery.AircraftName]
		if !aircraftExists {
			// Use 'Other' fallback
			aircraftTarget = mappings.AircraftMappings["Other"]
		}

		// Match livery_name column with AirlineMappings
		airlineTarget, airlineExists := mappings.AirlineMappings[livery.LiveryName]
		if !airlineExists {
			// Use 'Other' fallback
			airlineTarget = mappings.AirlineMappings["Other"]
		}

		// Log the mapping being created
		log.Printf("Mapping livery %s: aircraft='%s'->'%s', airline='%s'->'%s'\n",
			livery.LiveryID, livery.AircraftName, aircraftTarget, livery.LiveryName, airlineTarget)

		// Create aircraft mapping row
		// ID is auto-generated by PostgreSQL
		aircraftMapping := LiveryAirtableMapping{
			VAID:        VA_ID,
			LiveryID:    livery.LiveryID,
			FieldType:   "aircraft",
			SourceValue: livery.AircraftName,
			TargetValue: aircraftTarget,
			IsActive:    true,
		}

		// Create airline mapping row
		// ID is auto-generated by PostgreSQL
		airlineMapping := LiveryAirtableMapping{
			VAID:        VA_ID,
			LiveryID:    livery.LiveryID,
			FieldType:   "airline",
			SourceValue: livery.LiveryName,
			TargetValue: airlineTarget,
			IsActive:    true,
		}

		// Upsert aircraft mapping
		// On conflict (va_id, livery_id, field_type), update the target_value and updated_at
		result := db.Clauses(clause.OnConflict{
			Columns:   []clause.Column{{Name: "va_id"}, {Name: "livery_id"}, {Name: "field_type"}},
			DoUpdates: clause.AssignmentColumns([]string{"target_value", "source_value", "updated_at", "is_active"}),
		}).Create(&aircraftMapping)

		if result.Error != nil {
			return created, updated, fmt.Errorf("failed to upsert aircraft mapping for livery %s: %w", livery.LiveryID, result.Error)
		}

		if result.RowsAffected == 1 {
			created++
		} else {
			updated++
		}

		// Upsert airline mapping
		result = db.Clauses(clause.OnConflict{
			Columns:   []clause.Column{{Name: "va_id"}, {Name: "livery_id"}, {Name: "field_type"}},
			DoUpdates: clause.AssignmentColumns([]string{"target_value", "source_value", "updated_at", "is_active"}),
		}).Create(&airlineMapping)

		if result.Error != nil {
			return created, updated, fmt.Errorf("failed to upsert airline mapping for livery %s: %w", livery.LiveryID, result.Error)
		}

		if result.RowsAffected == 1 {
			created++
		} else {
			updated++
		}
	}

	return created, updated, nil
}
